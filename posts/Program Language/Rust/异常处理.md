# 1. 不可恢复错误
使用`panic!`抛出，直接中断该线程。
- 触发在主线程（`main`）：程序退出。
- 触发在非主线程：终止当前线程，并等待`std::thread::join()`方法收集。
# 2. 可恢复错误（异常）
## 2.1 抛出异常
将可能抛出异常的方法声明为返回如下的一个枚举类型：
``` Rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
## 2.2 捕获异常
### 2.2.1 模式匹配
返回时通过模式匹配判断是否有异常抛出，示例：
``` Rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error)
        },
    };
}
```
### 2.2.2 不处理直接`panic`
如果不想处理异常，失败直接抛出`panic`，则使用`unwrap`和`except`：
``` Rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}

// 使用自定义错误提示信息
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```
### 2.2.3 向上传播异常链条
通过继续返回`Result<T, E>`的形式向上抛出无法处理的异常。
``` Rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    // 打开文件，f是`Result<文件句柄,io::Error>`
    let f = File::open("hello.txt");

    let mut f = match f {
        // 打开文件成功，将file句柄赋值给f
        Ok(file) => file,
        // 打开文件失败，将错误返回(向上传播)
        Err(e) => return Err(e),
    };
    // 创建动态字符串s
    let mut s = String::new();
    // 从f文件句柄读取数据并写入s中
    match f.read_to_string(&mut s) {
        // 读取成功，返回Ok封装的字符串
        Ok(_) => Ok(s),
        // 将错误向上传播
        Err(e) => Err(e),
    }
}
```
使用`?`宏简化异常传播：
``` Rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    // 如果为Err则直接向上传播
    f.read_to_string(&mut s)?;
    Ok(s)
}

fn open_file() -> Result<File, Box<dyn std::error::Error>> {
    // ?宏会自动匹配基类Error
    // open返回io::error，自动转化为error::Error
    let mut f = File::open("hello.txt")?;
    Ok(f)
}
```
链式调用：
``` Rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```
`?`宏还可以匹配`Option`枚举中的`None`：
``` Rust
fn first(arr: &[i32]) -> Option<&i32> {
   let v = arr.get(0)?;
   Some(v)
}
```
### 2.2.4 `main`函数返回异常值
``` Rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```