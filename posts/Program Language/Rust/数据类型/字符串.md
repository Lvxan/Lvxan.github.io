# 1. 类型
字符类型底层为`Unicode`，占4字节
内置类型：`str`，硬编码进可执行文件，也无法被修改。
标准库类型：`String`，可增长、可改变且具有所有权的 `UTF-8` 编码字符串。
互相转化：
``` Rust
// &str To String
String::from("hello,world")
"hello,world".to_string()

// String To &str
fn main() {
    let s = String::from("hello,world!");
    // 隐式转化
    say_hello(&s);
    say_hello(&s[..]);
    // 显式转化
    say_hello(s.as_str());
}

fn say_hello(s: &str) {
    println!("{}",s);
}
```
# 2. 声明
``` Rust
// 创建一个String字符串，但是s1为不可变引用
let s1 = String::from("Hello World");
// 创建一个String字符串，s2为可变引用
let mux s2 = String::from("Hello World");
// 直接引用字符串，s3为&str类型
let s3 = "Hello World";
```
# 3. 操作
## 3.1 索引
不支持直接索引
## 3.2 切片
下标以字节为索引
``` Rust
// 英文字符占1字节
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];

// UTF-8中文字符占3字节
 let s = "中国人";
 let a = &s[0..2];
 println!("{}",a);    // echo "中"
 ```
切片操作返回值类型为`&str`，为不可变借用
``` Rust
// 切片返回一个不可变借用
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
fn first_word(s: &String) -> &str {
    &s[..1]
}

// 该代码会报错
// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
//   --> src/main.rs:18:5
//    |
// 16 |     let word = first_word(&s);
//    |                           -- immutable borrow occurs here
// 17 |
// 18 |     s.clear(); // error!
//    |     ^^^^^^^^^ mutable borrow occurs here
// 19 |
// 20 |     println!("the first word is: {}", word);
//    |                                       ---- immutable borrow later used here
```
## 3.3 修改
1. 参数包含下标的方法，以实际字节的索引下标为基础，如果操作的下标不是字符开头则会报错
``` Rust
// 插入
let mut s = String::from("Hello rust!");
s.insert(5, ',');
println!("插入字符 insert() -> {}", s);

// 删除
// remove，删除字符，直接操作原来的字符串。
// 但是存在返回值，其返回值是删除位置的字符串
let mut string_remove = String::from("测试remove方法");
// 只接收一个参数，表示该字符起始索引位置
string_remove.remove(0);
// 下面代码会发生错误
// string_remove.remove(1);
// 直接删除第二个汉字
// string_remove.remove(3);

// truncate，删除字符串中从指定位置开始到结尾的全部字符，直接操作原来的字符串
// 无返回值
let mut string_truncate = String::from("测试truncate");
// 如果参数所给的位置不是合法的字符边界，则会发生错误
string_truncate.truncate(3);

// clear，清空字符串，直接操作原来的字符串
let mut string_clear = String::from("string clear");
string_clear.clear();
```
2. 参数不包含下标的方法
``` Rust
// 替换
// replace，替换所有匹配
let string_replace = String::from("I like rust. Learning rust is my favorite!");
let new_string_replace = string_replace.replace("rust", "RUST");
// replacen，替换指定数量的匹配，从头开始查找
let new_string_replacen = string_replace.replacen("rust", "RUST", 1);
```
## 3.4 连接
1. `add()`方法
定义：
``` Rust
fn add(self, s: &str) -> String
```
+操作相当于调用`add()`方法：
``` Rust
let s1 = String::from("hello,");
let s2 = String::from("world!");
// 在下句中，s1的所有权被转移走了，因此后面不能再使用s1
// &s2会自动解引用为&str
let s3 = s1 + &s2;

// 嵌套调用
// String = String + &str + &str + &str + &str
let s = s1 + "-" + &s2 + "-" + &s3;
```
2. `format!`方法
格式化输出`String`和`&str`，与`print!`类似：
``` Rust
fn main() {
    let s1 = "hello";
    let s2 = String::from("rust");
    let s = format!("{} {}!", s1, s2);
    println!("{}", s);
}
```
## 3.5 遍历
1. 字符遍历
``` Rust
for c in "中国人".chars() {
    println!("{}", c);
}
```
2. 字节遍历
``` Rust
for b in "中国人".bytes() {
    println!("{}", b);
}
```
## 3.6 转义
``` Rust
// 通过 \ + 字符的十六进制表示，转义输出一个字符
let byte_escape = "I'm writing \x52\x75\x73\x74!";
// \u 可以输出一个 unicode 字符
let unicode_codepoint = "\u{211D}";

// 保留原串不进行转义
let raw_str = r"Escapes don't work here: \x3F \u{211D}";
// 如果字符串包含双引号，可以在开头和结尾加 #
let quotes = r#"And then I said: "There is no escape!""#;
// 如果字符串中包含 # 号，可以在开头和结尾加多个 # 号
// 最多加255个，只需保证与字符串中连续 # 号的个数不超过开头和结尾的 # 号的个数即可
let longer_delimiter = r###"A string with "# in it. And even "##!"###;
```