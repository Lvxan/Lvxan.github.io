---
title: '标准库基础类型'
date: 2025-08-15  
author: 'CK'
tags: ['Study','Note']
---

Rust 标准库基础类型笔记

---

## 1. 集合类型
### 1.1 字符串
详见[字符串](./字符串.md)。
### 1.2 Vector
#### 1.2.1 创建
``` Rust
let mut v = Vec::new();
v.push(1);

// 创建时直接赋初始值
let v = vec![1, 2, 3];

// 其他方式
let v = vec![0; 3];   // 默认值为 0，初始长度为 3
let v_from = Vec::from([0, 0, 0]);
let mut v = Vec::with_capacity(10);    // 指定初始容量
```
#### 1.2.2 读取
``` Rust
let v = vec![1, 2, 3, 4, 5];

// 下标，不可变借用，越界时直接崩溃
let third: &i32 = &v[2];
println!("第三个元素是 {}", third);

// get方法，返回Option<T>类型，越界时返回None
match v.get(2) {
    Some(third) => println!("第三个元素是 {third}"),
    None => println!("去你的第三个元素，根本没有！"),
}
```
同时借用多个数组元素时容易存在的问题：
``` Rust
let mut v = vec![1, 2, 3, 4, 5];
// 此处为不可变借用
let first = &v[0];
// 此处为可变借用
v.push(6);
// 在可变借用后使用不可变借用，报错
println!("The first element is: {first}");
```
报错原因：`Vector`的大小是可变的，当旧数组的大小不够用时，`Rust`会重新分配一块更大的内存空间，然后把旧数组拷贝过来。这种情况下，之前的不可变借用`first`就会指向一块无效的内存。
#### 1.2.3 迭代器访问
``` Rust
let v = vec![1, 2, 3];

// 不可变借用
for i in &v {
    println!("{i}");
}

// 可变借用
for i in &mut v {
    *i += 10
}
```
#### 1.2.4 其他常用方法
``` Rust
v.reserve(100);        // 调整 v 的容量，至少要有 100 的容量
v.shrink_to_fit();     // 释放剩余的容量，一般情况下，不会主动去释放容量
v.is_empty();          // 检查 v 是否为空
v.insert(2, 3);        // 在指定索引插入数据，索引值不能大于 v 的长度， v: [1, 2, 3] 
v.remove(1);           // 移除指定位置的元素并返回, v: [1, 3]
v.pop();               // 删除并返回 v 尾部的元素，类型为Option<T>，v: [1]
v.clear();             // 清空 v, v: []

let mut v1 = [11, 22].to_vec(); // append 操作会导致 v1 清空数据，增加可变声明
v.append(&mut v1);              // 将 v1 中的所有元素附加到 v 中, v1: []
v.truncate(1);                  // 截断到指定长度，多余的元素被删除, v: [11]
v.retain(|x| *x > 10);          // 保留满足条件的元素，即删除不满足条件的元素

let mut v = vec![11, 22, 33, 44, 55];
// 删除指定范围的元素，同时获取被删除元素的迭代器, v: [11, 55], m: [22, 33, 44]
let mut m: Vec<_> = v.drain(1..=3).collect();    
let v2 = m.split_off(1);        // 指定索引处切分成两个 vec, m: [22], v2: [33, 44]
// 数组切片方式
let v = vec![11, 22, 33, 44, 55];
let slice = &v[1..=3];
```
#### 1.2.5 排序
``` Rust
let mut vec = vec![1, 5, 10, 2, 15];
// 稳定排序
vec.sort();
// 不稳定排序
vec.sort_unstable();

let mut vec = vec![1.0, 5.6, 10.3, 2.0, 15f32];
// 稳定排序，通过指定自定义对比函数
vec.sort_by(|a, b| a.partial_cmp(b).unwrap());
// 不稳定排序，通过指定自定义对比函数
vec.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());
```
对自定义结构体进行排序，需要实现`Ord`特性，该特性需要实现`Ord`、`Eq`、`PartialEq`、`PartialOrd`。
``` Rust
// 使用默认实现
#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]
struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn new(name: String, age: u32) -> Person {
        Person { name, age }
    }
}

fn main() {
    let mut people = vec![
        Person::new("Zoe".to_string(), 25),
        Person::new("Al".to_string(), 60),
        Person::new("Al".to_string(), 30),
        Person::new("John".to_string(), 1),
        Person::new("John".to_string(), 25),
    ];

    people.sort_unstable();

    println!("{:?}", people);
}

// Print：
// [Person { name: "Al", age: 30 }, Person { name: "Al", age: 60 }, 
// Person { name: "John", age: 1 }, Person { name: "John", age: 25 }, 
// Person { name: "Zoe", age: 25 }]
```
需要 `derive Ord` 相关特性，需要确保结构体中所有的属性均实现了 `Ord` 相关特性，否则会发生编译错误。`derive` 的默认实现会依据属性的顺序依次进行比较，如上述例子中，当 `Person` 的 `name` 值相同，则会使用 `age` 进行比较。

### 1.3 HashMap
#### 1.3.1 创建
``` Rust
// HashMap没有被编译器prelude，需要手动引用
use std::collections::HashMap;

// 创建一个HashMap，用于存储宝石种类和对应的数量
let mut my_gems = HashMap::new();

// 将宝石类型和对应的数量写入表中
my_gems.insert("红宝石", 1);
my_gems.insert("蓝宝石", 2);
my_gems.insert("河边捡的误以为是宝石的破石头", 18);
```
从`Vector`创建：
``` Rust
fn main() {
    use std::collections::HashMap;

    let teams_list = vec![
        ("中国队".to_string(), 100),
        ("美国队".to_string(), 10),
        ("日本队".to_string(), 50),
    ];

    // 先转化为迭代器，再collect
    let teams_map: HashMap<_,_> = teams_list.into_iter().collect();
    
    println!("{:?}",teams_map)
}
```
所有权问题：
- 若类型实现 `Copy` 特征，该类型会被复制进 `HashMap`，因此无所谓所有权。
- 若没实现 `Copy` 特征，所有权将被转移给 `HashMap` 中。
指定计算`Key`所用的`Hash`函数：
``` Rust
use std::hash::BuildHasherDefault;
use std::collections::HashMap;
// 引入第三方的哈希函数
use twox_hash::XxHash64;

// 指定HashMap使用第三方的哈希函数XxHash64
let mut hash: HashMap<_, _, BuildHasherDefault<XxHash64>> = Default::default();
hash.insert(42, "the answer");
assert_eq!(hash.get(&42), Some(&"the answer"));
```
### 1.3.2 查询
``` Rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
// get方法查询，返回一个借用
let score: Option<&i32> = scores.get(&team_name);
// 获得值类型
let score: i32 = scores.get(&team_name).copied().unwrap_or(0);

// 遍历
for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```
#### 1.3.3 插入
``` Rust
fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert("Blue", 10);

    // 覆盖已有的值
    let old = scores.insert("Blue", 20);
    assert_eq!(old, Some(10));

    // 查询新插入的值
    let new = scores.get("Blue");
    assert_eq!(new, Some(&20));

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry("Yellow").or_insert(5);
    assert_eq!(*v, 5); // 不存在，插入5

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry("Yellow").or_insert(50);
    assert_eq!(*v, 5); // 已经存在，因此50没有插入
}
```