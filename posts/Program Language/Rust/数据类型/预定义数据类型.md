# 1. 基本数据类型
以下类型均存储在栈上，并默认实现`copy`：
- 数值  
  
| 长度 | 有符号类型 | 无符号类型 |  
| --- | -------- | --------- |  
| 8位 | `i8` | `u8` |  
| 16位 | `i16` | `u16` |  
| 32位 | `i32` | `u32` |  
| 64位 | `i64` | `u64` |  
| 128位 | `i128` | `u128` |  
| 取决于CPU架构 | `isize` | `usize` |  

默认使用`i32`，`isize`、`usize`用作集合的索引。  
`IEEE-754`标准浮点型：`f32`、`f64`。  
`Range`：`[1,5)`使用`1..5`表示，`[1,5]`使用`1..=5`表示。  
有理数、复数：使用`num`库。  
- 字符（`char`）：使用`Unicode`编码，占4字节。
- 布尔（`bool`）：`true`和`false`，占1字节。
- 单元（`unit`）：`()`，不占用任何内存。
# 2. 元组
``` Rust
fn main() {
    // 基本定义
    let tup = (500, 6.4, 1);
    // 解构元组
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);
    
    // 访问元组
    let t: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = t.0;
    let six_point_four = t.1;
    let one = t.2;
}
```
# 3. 枚举——enum
## 3.1 基本定义
``` Rust
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}

// 访问
let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
```
## 3.2 关联类型
枚举类型的值可以附加其他类型
``` Rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

enum Websocket {
  Tcp(Websocket<TcpStream>),
  Tls(Websocket<native_tls::TlsStream<TcpStream>>),
}

// 处理空值
enum Option<T> {
    Some(T),
    None,
}
```
# 4. 结构体——struct
## 4.1 基本定义
<!-- TODO: 完善该部分 -->

## 4.2 泛型
<!-- TODO: 完善该部分 -->

# 5. 特征——trait
## 5.1 定义
``` Rust
// 定义特征Summary
pub trait Summary {
    fn summarize(&self) -> String;
}
// 定义结构体Post
pub struct Post {
    pub title: String, // 标题
    pub author: String, // 作者
    pub content: String, // 内容
}
// 为Post实现Summary特征
impl Summary for Post {
    fn summarize(&self) -> String {
        format!("文章{}, 作者是{}", self.title, self.author)
    }
}
// 使用特征
fn main() {
    let post = Post{title: "Rust语言简介".to_string(), author: "Sunface".to_string(), content: "Rust棒极了!".to_string()};
    println!("{}", post.summarize());
}
```
**孤儿规则**：如果你想要为类型 `A` 实现特征 `T`，那么 `A` 或者 `T` 至少有一个是在当前作用域中定义的！例如：无法在当前作用域中，为 `String` 类型实现 `Display` 特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域。
提供默认实现
``` Rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
// 使用默认实现
impl Summary for Post {}
```
## 5.2 实现多态
``` Rust
// 将Summary特征作为形参类型，实现多态
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
// 等价于
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```
## 5.3 特征约束
``` Rust
// 要求形参item1和item2都实现了Summary特征，但实际类型可以不同（因为多态）
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
// 要求形参item1和item2都为实现Summary特征的类型T
pub fn notify<T: Summary>(item1: &T, item2: &T) {}

// 多重约束
// 约束T类型必须同时实现特征Summary和Display
pub fn notify(item: &(impl Summary + Display)) {}
// 或者
pub fn notify<T: Summary + Display>(item: &T) {}

// 使用where进行复杂约束
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
// 等价于
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
```
在泛型中指定特征类型进行实现，也就是为泛型结构体中特定类提供特定的方法实现：
``` Rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

// Pair类的一般方法实现
impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

// 特化Pair类的方法实现
// 为同时实现Display和PartialOrd特征的T类型指定cmp_display方法实现
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```
有条件地实现特征：
``` Rust
// 为所有实现Display特征的类型实现ToString特征
impl<T: Display> ToString for T {
    // --snip--
}
```
## 5.4 函数返回特征
``` Rust
fn returns_summarizable() -> impl Summary {
    Weibo {
        username: String::from("sunface"),
        content: String::from(
            "m1 max太厉害了，电脑再也不会卡",
        )
    }
}
```
限制：返回值必须只能为一种具体类型，也就是不能通过`if-else`返回两种可能的类型， 即使这两种类型都实现了`Summary`特征
## 5.5 使用derive派生特征
``` Rust
#[derive(Debug)]    // 为标记的类型默认派生指定的特征
struct StructNoDisplay {}
```
## 5.6 特征对象
``` Rust
// 使用dyn关键字声明特征对象类型
pub struct Screen {
    // 所有实现Draw特征的对象都可以存储在向量中
    pub components: Vec<Box<dyn Draw>>,
}
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            // 多态，动态查找调用对应对象的draw方法
            component.draw();
        }
    }
}

// 特征约束型
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}
impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            // 无法多态，调用T类型对应的draw方法，但性能更好
            component.draw();
        }
    }
}
```
限制：不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：
- 方法的返回类型不能是 `Self`
- 方法没有任何泛型参数

## 5.7 关联类型
``` Rust
pub trait Iterator {
    // 声明关联类型Item
    type Item;
    
    // 使用关联类型Item
    fn next(&mut self) -> Option<Self::Item>;
}
// 实现示例
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
    }
}
// 约束关联类型
trait Container{
    type A：Display;
    type B;
    fn contains(&self, a: &Self::A, b: &Self::B) -> bool;
}
```
## 5.8 默认泛型参数
``` Rust
// 默认使用Self类型作为RHS的实际类型
trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}
```
## 5.9 处理同名方法
``` Rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}
// Human实例会优先调用该方法
impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
// 显示调用特征的方法
fn main() {
    let person = Human;
    Pilot::fly(&person); // 调用Pilot特征上的方法
    Wizard::fly(&person); // 调用Wizard特征上的方法
    person.fly(); // 调用Human类型自身的方法
}
```
对于无`self`形参的方法，实例如何调用同名的特征方法：
``` Rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    // 调用Dog中声明的方法
    println!("A baby dog is called a {}", Dog::baby_name());
    // 调用特征对应的方法，使用完全限定语法
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```
完全限定语法：
``` Rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```
## 5.10 特征继承
``` Rust
use std::fmt::Display;
use std::fmt;

// 实现OutlinePrint特征需要首先实现Display
// 也就是说OutlinePrint受Display约束
trait OutlinePrint: Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

// 示例：实现OutlinePrint
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
impl Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```
## 5.11 如何绕过孤儿规则
使用`newtype`模式，简而言之：就是为一个元组结构体封装掉该类型再实现，此时封装的类型定义就在内部了。
``` Rust
// 示例：为Vec<T>类型实现Display特征
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```