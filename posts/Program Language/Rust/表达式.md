---
title: '表达式'
date: 2025-08-15  
author: 'CK'
tags: ['Study','Note']
---

Rust 表达式笔记

---

## 1. 普通表达式
``` Rust
// 所有权转移
let mut s = String::from("Hello World!");
```
## 2. 返回值
``` Rust
// 不加分号表示返回
fn new_str() -> &str {
    let mut s = String::from("Hello World!");
    &s[..5]
}
```
## 3. 闭包（匿名函数/`Lambda`表达式）
``` Rust
let array: [String; 8] = std::array::from_fn(|_i| String::from("Hello World!"));

// 等价于
fn generate_string(_i: usize) -> String {
    String::from("Hello World!")
}
let array: [String; 8] = std::array::from_fn(generate_string);
```
## 4. 模式匹配
### 4.1 `match`匹配
#### 4.1.1 一般模式
``` Rust
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
}
```
#### 4.1.2 忽略部分值
``` Rust
// 忽略部分值
let mut setting_value = Some(5);
let new_setting_value = Some(10);
match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
        println!("Can't overwrite an existing customized value");
    }
    _ => {
        setting_value = new_setting_value;
    }
}
println!("setting is {:?}", setting_value);
```
#### 4.1.3 忽略剩余值
``` Rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}
let origin = Point { x: 0, y: 0, z: 0 };
match origin {
    Point { x, .. } => println!("x is {}", x),
}
```
#### 4.1.4 设置额外条件
``` Rust
let num = Some(4);
match num {
    Some(x) if x < 5 => println!("less than five: {}", x),
    Some(x) => println!("{}", x),
    None => (),
}
```
#### 4.1.5 `@`绑定
在模式匹配时将匹配到的值绑定到变量：
``` Rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
```
使用 `@` 还可以在绑定新变量的同时，对目标进行解构：
``` Rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 绑定新变量 `p`，同时对 `Point` 进行解构
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!("x: {}, y: {}", px, py);
    println!("{:?}", p);


    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!("x is 10 and y is {} in {:?}", y, p);
    } else {
        println!("x was not 10 :(");
    }
}
```
``` Rust
新特性：
fn main() {
    match 1 {
        num @ 1 | 2 => {
            println!("{}", num);
        }
        _ => {}
    }
}
```
### 4.2 if let匹配
``` Rust
if let Some(3) = v {
    println!("three");
}
// 等价于
let v = Some(3u8);
match v {
    Some(3) => println!("three"),
    _ => (),
}
```
### 4.3 while let循环
``` Rust
// Vec是动态数组
let mut stack = Vec::new();

// 向数组尾部插入元素
stack.push(1);
stack.push(2);
stack.push(3);

// stack.pop从数组尾部弹出元素
// 直到stack.pop()返回None，不满足Some()模式，退出循环
while let Some(top) = stack.pop() {
    println!("{}", top);
}
```
### 4.4 let else匹配
用`else`分支处理不匹配情况，获得变量的作用域更广。（需要rust版本>= 1.65）
``` Rust
// let-else
let Some(x) = some_option_value else { return; }
println!("{}", x);    // x在此也有效

// if let
if let Some(x) = some_option_value {
    // x仅在此大括号内有效
    println!("{}", x);
}
```
### 4.5 matches!宏
用于返回匹配结果的布尔值，将前值代入后值进行模式匹配。
``` Rust
v.iter().filter(|x| matches!(x, MyEnum::Foo));

let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2));
```
### 4.6 单分支多模式
``` Rust
let x = 1;
match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}

let x = 5;
match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```